## 상속
---

> 상속을 이용해 이미 개발된 클래스를 재사용하여 새로운 클래스의 코드 중복을 줄일 수 있다

### 부모 생성자 호출

부모 클래스에 기본 생성자(생성자 따로 정의 안하는 경우)가 없고 매개 변수가 있는 생성자만 있다면
자식 생성자에서 반드시 부모 생성자 호출을 위해 super(parameter, ...)를 자식 생성자 첫 줄에 호출해야한다



### @Override (메소드 재정의)

부모 클래스에 있는 메소드를 자식 클래스에서 재정의하여 사용하는 것을 의미한다. 메소드 호출 시 override된 메소드가 호출된다. 부모의 메소드와 동일한 시그니쳐를 갖으며 부모 클래스의 접근 제한보다 더 강한 접근 제한을 둘 수 없다

override된 메소드가 아닌 기존의 부모 클래스의 메소드를 사용해야 할 경우 아래와 같이 사용한다. 직접 접근 가능

```java
suepr.부모메소드();
```



### final class, final method

* final class : 부모 클래스가 될 수 없다. 따라서 상속 불가능

* final method : 일반 부모 클래스에서 선언된 final method는 override 불가능



### 자동 타입 변환(Promotion)

부모 클래스 : Animal, 자식 클래스 : Dog

```java
Animal animal = new Dog();
```

큰 그릇(Animal)에 작은 그릇(Dog)을 담을 수 있다고 생각하면 쉽다

부모 타입으로 자동 타입 변환 된 이후에는 부모 클래스 멤버만 접근 가능하다

하지만 자식 클래스에서 override된 메소드라면 자식 클래스의 메소드가 호출된다

그러면, 굳이 자동 타입 변환 왜? -> 다형성 !



### 강제 타입 변환(Casting)

```java

// 자동 타입 변환
Animal animal = new Dog();
// 강제 타입 변환
Dog dog = (Dog) animal;
```

자식 타입이 부모 타입으로 자동 변환한 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다

자식 타입이 부모 타입으로 자동 타입 변환 된 경우 부모 클래스 멤버에만 접근 가능하기 때문에, 다시 자식 클래스 멤버에 접근하고자 할 때 강제 타입 변환을 사용한다



### 객체 타입 확인(instanceof)

어떤 객체가 어떤 클래스의 인스턴스인지 확인하고자 사용한다

예를 들어 강제 타입 변환을 하고자 할 때, 이전에 객체 타입이 이미 자동 타입 변환되었는지 확인해야 에러가 발생하지 않는다

```java
public static void method1(Animal animal) {
  if (animal instanceof Dog) {
    Dog dog = (Dog) animal;
  }
}
```


### 추상 클래스

실체 클래스들의 공통되는 특성을 가지고 있는 부모 클래스이다. 굳이 추상 클래스를 사용하는 이유는 설계자가 설계 규격을 만들어 코더에게 전달하기 위함이다. 또한 추상 클래스는 new 연산자를 사용해서 인스턴스를 생성시키지 못한다.

* 실체 클래스들의 공통된 멤버 이름을 통일

* 실체 클래스 작성 시 수고를 줄임

```java
public abstract class Animal {

}
```

* 추상 메소드

추상 메소드는 추상 클래스에서만 선언할 수 있다. 다른 메소드와 다르게 {} 붙이지 않는다. 자식 클래스에서 이를 사용할 때엔 override를 통해 구현한다

```java
public abstract class Animal {
  public abstract void sound();
}
```
